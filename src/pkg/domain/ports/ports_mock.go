// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package ports

import (
	"90poe/src/pkg/domain"
	"context"
	"io"
	"sync"
)

// Ensure, that PortParserMock does implement PortParser.
// If this is not the case, regenerate this file with moq.
var _ PortParser = &PortParserMock{}

// PortParserMock is a mock implementation of PortParser.
//
//	func TestSomethingThatUsesPortParser(t *testing.T) {
//
//		// make and configure a mocked PortParser
//		mockedPortParser := &PortParserMock{
//			ParserReaderFunc: func(reader io.Reader, nextPort chan domain.Port, errChannel chan error)  {
//				panic("mock out the ParserReader method")
//			},
//		}
//
//		// use mockedPortParser in code that requires PortParser
//		// and then make assertions.
//
//	}
type PortParserMock struct {
	// ParserReaderFunc mocks the ParserReader method.
	ParserReaderFunc func(reader io.Reader, nextPort chan domain.Port, errChannel chan error)

	// calls tracks calls to the methods.
	calls struct {
		// ParserReader holds details about calls to the ParserReader method.
		ParserReader []struct {
			// Reader is the reader argument value.
			Reader io.Reader
			// NextPort is the nextPort argument value.
			NextPort chan domain.Port
			// ErrChannel is the errChannel argument value.
			ErrChannel chan error
		}
	}
	lockParserReader sync.RWMutex
}

// ParserReader calls ParserReaderFunc.
func (mock *PortParserMock) ParserReader(reader io.Reader, nextPort chan domain.Port, errChannel chan error) {
	if mock.ParserReaderFunc == nil {
		panic("PortParserMock.ParserReaderFunc: method is nil but PortParser.ParserReader was just called")
	}
	callInfo := struct {
		Reader     io.Reader
		NextPort   chan domain.Port
		ErrChannel chan error
	}{
		Reader:     reader,
		NextPort:   nextPort,
		ErrChannel: errChannel,
	}
	mock.lockParserReader.Lock()
	mock.calls.ParserReader = append(mock.calls.ParserReader, callInfo)
	mock.lockParserReader.Unlock()
	mock.ParserReaderFunc(reader, nextPort, errChannel)
}

// ParserReaderCalls gets all the calls that were made to ParserReader.
// Check the length with:
//
//	len(mockedPortParser.ParserReaderCalls())
func (mock *PortParserMock) ParserReaderCalls() []struct {
	Reader     io.Reader
	NextPort   chan domain.Port
	ErrChannel chan error
} {
	var calls []struct {
		Reader     io.Reader
		NextPort   chan domain.Port
		ErrChannel chan error
	}
	mock.lockParserReader.RLock()
	calls = mock.calls.ParserReader
	mock.lockParserReader.RUnlock()
	return calls
}

// Ensure, that PortRepositoryMock does implement PortRepository.
// If this is not the case, regenerate this file with moq.
var _ PortRepository = &PortRepositoryMock{}

// PortRepositoryMock is a mock implementation of PortRepository.
//
//	func TestSomethingThatUsesPortRepository(t *testing.T) {
//
//		// make and configure a mocked PortRepository
//		mockedPortRepository := &PortRepositoryMock{
//			FindByKeyFunc: func(ctx context.Context, key string) (domain.Port, error) {
//				panic("mock out the FindByKey method")
//			},
//			SaveFunc: func(ctx context.Context, port domain.Port) error {
//				panic("mock out the Save method")
//			},
//		}
//
//		// use mockedPortRepository in code that requires PortRepository
//		// and then make assertions.
//
//	}
type PortRepositoryMock struct {
	// FindByKeyFunc mocks the FindByKey method.
	FindByKeyFunc func(ctx context.Context, key string) (domain.Port, error)

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, port domain.Port) error

	// calls tracks calls to the methods.
	calls struct {
		// FindByKey holds details about calls to the FindByKey method.
		FindByKey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Port is the port argument value.
			Port domain.Port
		}
	}
	lockFindByKey sync.RWMutex
	lockSave      sync.RWMutex
}

// FindByKey calls FindByKeyFunc.
func (mock *PortRepositoryMock) FindByKey(ctx context.Context, key string) (domain.Port, error) {
	if mock.FindByKeyFunc == nil {
		panic("PortRepositoryMock.FindByKeyFunc: method is nil but PortRepository.FindByKey was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockFindByKey.Lock()
	mock.calls.FindByKey = append(mock.calls.FindByKey, callInfo)
	mock.lockFindByKey.Unlock()
	return mock.FindByKeyFunc(ctx, key)
}

// FindByKeyCalls gets all the calls that were made to FindByKey.
// Check the length with:
//
//	len(mockedPortRepository.FindByKeyCalls())
func (mock *PortRepositoryMock) FindByKeyCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockFindByKey.RLock()
	calls = mock.calls.FindByKey
	mock.lockFindByKey.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *PortRepositoryMock) Save(ctx context.Context, port domain.Port) error {
	if mock.SaveFunc == nil {
		panic("PortRepositoryMock.SaveFunc: method is nil but PortRepository.Save was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Port domain.Port
	}{
		Ctx:  ctx,
		Port: port,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, port)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedPortRepository.SaveCalls())
func (mock *PortRepositoryMock) SaveCalls() []struct {
	Ctx  context.Context
	Port domain.Port
} {
	var calls []struct {
		Ctx  context.Context
		Port domain.Port
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// Ensure, that PortServiceMock does implement PortService.
// If this is not the case, regenerate this file with moq.
var _ PortService = &PortServiceMock{}

// PortServiceMock is a mock implementation of PortService.
//
//	func TestSomethingThatUsesPortService(t *testing.T) {
//
//		// make and configure a mocked PortService
//		mockedPortService := &PortServiceMock{
//			GetPortByKeyFunc: func(ctx context.Context, key string) (domain.Port, error) {
//				panic("mock out the GetPortByKey method")
//			},
//			SavePortFunc: func(ctx context.Context, port domain.Port) error {
//				panic("mock out the SavePort method")
//			},
//		}
//
//		// use mockedPortService in code that requires PortService
//		// and then make assertions.
//
//	}
type PortServiceMock struct {
	// GetPortByKeyFunc mocks the GetPortByKey method.
	GetPortByKeyFunc func(ctx context.Context, key string) (domain.Port, error)

	// SavePortFunc mocks the SavePort method.
	SavePortFunc func(ctx context.Context, port domain.Port) error

	// calls tracks calls to the methods.
	calls struct {
		// GetPortByKey holds details about calls to the GetPortByKey method.
		GetPortByKey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// SavePort holds details about calls to the SavePort method.
		SavePort []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Port is the port argument value.
			Port domain.Port
		}
	}
	lockGetPortByKey sync.RWMutex
	lockSavePort     sync.RWMutex
}

// GetPortByKey calls GetPortByKeyFunc.
func (mock *PortServiceMock) GetPortByKey(ctx context.Context, key string) (domain.Port, error) {
	if mock.GetPortByKeyFunc == nil {
		panic("PortServiceMock.GetPortByKeyFunc: method is nil but PortService.GetPortByKey was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockGetPortByKey.Lock()
	mock.calls.GetPortByKey = append(mock.calls.GetPortByKey, callInfo)
	mock.lockGetPortByKey.Unlock()
	return mock.GetPortByKeyFunc(ctx, key)
}

// GetPortByKeyCalls gets all the calls that were made to GetPortByKey.
// Check the length with:
//
//	len(mockedPortService.GetPortByKeyCalls())
func (mock *PortServiceMock) GetPortByKeyCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockGetPortByKey.RLock()
	calls = mock.calls.GetPortByKey
	mock.lockGetPortByKey.RUnlock()
	return calls
}

// SavePort calls SavePortFunc.
func (mock *PortServiceMock) SavePort(ctx context.Context, port domain.Port) error {
	if mock.SavePortFunc == nil {
		panic("PortServiceMock.SavePortFunc: method is nil but PortService.SavePort was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Port domain.Port
	}{
		Ctx:  ctx,
		Port: port,
	}
	mock.lockSavePort.Lock()
	mock.calls.SavePort = append(mock.calls.SavePort, callInfo)
	mock.lockSavePort.Unlock()
	return mock.SavePortFunc(ctx, port)
}

// SavePortCalls gets all the calls that were made to SavePort.
// Check the length with:
//
//	len(mockedPortService.SavePortCalls())
func (mock *PortServiceMock) SavePortCalls() []struct {
	Ctx  context.Context
	Port domain.Port
} {
	var calls []struct {
		Ctx  context.Context
		Port domain.Port
	}
	mock.lockSavePort.RLock()
	calls = mock.calls.SavePort
	mock.lockSavePort.RUnlock()
	return calls
}
